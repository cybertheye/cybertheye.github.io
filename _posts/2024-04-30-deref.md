---
title: ğŸ§€ é€šè¿‡derefé—´æ¥è°ƒç”¨æ–¹æ³•
layout: post
author: cyven
tags: rust deref method
categories: CS CS::Lang CS::Lang::Rust
---

æ˜¨å¤©çœ‹ `RefCell<T>` [æ–‡æ¡£](https://doc.rust-lang.org/book/ch15-05-interior-mutability.html#:~:text=Having%20Multiple%20Owners%20of%20Mutable%20Data%20by%20Combining%20Rc%3CT%3E%20and%20RefCell%3CT%3E)çš„æ—¶å€™,

```rust
#[derive(Debug)]
enum List {
    Cons(Rc<RefCell<i32>>, Rc<List>),
    Nil,
}

use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

fn main() {
    let value = Rc::new(RefCell::new(5));

    let a = Rc::new(Cons(Rc::clone(&value), Rc::new(Nil)));

    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&a));
    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&a));

    *value.borrow_mut() += 10;

    println!("a after = {:?}", a);
    println!("b after = {:?}", b);
    println!("c after = {:?}", c);
}
```

å¯¹äº `*value.borrow_mut() += 10` çš„è§£é‡Š

> After weâ€™ve created the lists in a, b, and c, we want to add 10 to the value in value. We do this by calling borrow_mut on value, which uses the automatic dereferencing feature we discussed in Chapter 5 (see the section â€œWhereâ€™s the -> Operator?â€) to dereference the Rc<T> to the inner RefCell<T> value. The borrow_mut method returns a RefMut<T> smart pointer, and we use the dereference operator on it and change the inner value.

è¿™é‡Œè®©æˆ‘ä¸ä»…å¥½å¥‡ï¼Œæ˜¯ä¸æ˜¯è¿™æ ·çš„ï¼Ÿ

å°±æ˜¯
```
x -- Deref --> y
```

ç±»å‹xå¯ä»¥é€šè¿‡Derefå¾—åˆ°ç±»å‹y

å‡å¦‚ y æœ‰ä¸€ä¸ªæ–¹æ³•  `fn foo(&self)`

é‚£æ˜¯ä¸æ˜¯ xå¯ä»¥ç›´æ¥è°ƒç”¨è¿™ä¸ªfooï¼Œä¹Ÿå°±æ˜¯  `x.foo()` è¡Œå¾—é€šï¼Ÿ


ç»“è®ºæ˜¯å¯ä»¥çš„

```rust

struct Tess{
    val: String,
    id: i32,
}

use std::ops::Deref;

impl Deref for Tess{
    type Target = String;

    fn deref(&self) -> &Self::Target{
        &self.val
    }
}

fn main(){
    let a = Tess{val:"hello".to_string(),id:3};
    println!("{}",*a);
    println!("{}",a.len()); //ç›´æ¥è°ƒç”¨Stringçš„æ–¹æ³•len
}

/*
hello
5
*/
```

è‡³äºä¸ºä»€ä¹ˆï¼Œä¸Šé¢ä¹Ÿæåˆ°äº†ï¼Œä¸»è¦æ¶‰åŠåˆ°ä¸¤ç‚¹ï¼Œæˆ‘è®¤ä¸º

1. **when you call a method with object.something(), Rust automatically adds in &, &mut, or * so object matches the signature of the method**
2. Deref Coercion


å› ä¸º1ï¼Œ `a.len()`å®é™…ä¸Šæ˜¯`(&a).len()`
å› ä¸º2ï¼Œ `&a`æ˜¯`&Tess`, è€Œ`fn len(&self)`è¿™é‡Œå…¶å®æ˜¯éœ€è¦ `&String` ï¼Œç„¶åé€šè¿‡ **Deref Coercion** å¾—åˆ°`&String` ï¼Œä»è€Œå®Œæˆè°ƒç”¨ã€‚
