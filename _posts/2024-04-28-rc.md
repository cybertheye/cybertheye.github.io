---
title: ğŸ§€ å¦‚ä½•åˆ›å»ºå‡ºä¸€ä¸ªRc<T>ç±»å‹çš„reference å¾ªç¯
layout: post
author: cyven
tags: rust reference rc refcell
categories: CS CS::Lang CS::Lang::Rust
---

## reference cycle
rustlingsåˆ°äº† `Rc<T>` è¿™å—, å°±çœ‹äº†ä¸€ä¸‹å®˜æ–¹èµ„æ–™

çœ‹åˆ°

>  This function is named strong_count rather than count because the Rc<T> type also has a weak_count; weâ€™ll see what weak_count is used for in the â€œPreventing Reference Cycles: Turning an Rc<T> into a Weak<T>â€ section.

è¿™é‡Œçš„æ—¶å€™ï¼Œå°±åƒç°åœ¨å­¦åˆ°çš„ï¼Œæ€ä¹ˆå»åˆ›å»ºå‡ºä¸€ä¸ªå¼•ç”¨å¾ªç¯ï¼Ÿ

è¦åšçš„äº‹å°±å¾ˆç®€å•ï¼Œå›¾ä¸€ç”»ï¼Œå¿ƒæƒ³æ”¾é©¬è¿‡æ¥

![2024-04-30-01-42-33-screenshoot.png](../assets/img/2024-04-30-01-42-33-screenshoot.png)

ä½†å®é™…å†™äº†ä»£ç ï¼Œæ„Ÿè§‰ï¼ŒæŠŠé©¬ç‰µèµ°


é¦–å…ˆè¿™é‡Œå®šä¹‰

```rust
use std::rc::Rc;

enum List{
	Cons(i32,Rc<List>),
	Nil,
}

use List::{Cons,Nil};

```

æˆ‘æœ¬æƒ³ç€å…ˆå®šä¹‰å‡ºä¸€ä¸ªa,ç„¶åå†å®šä¹‰å¦å¤–ä¸€ä¸ªb,è¿™æ—¶å€™bå°±é“¾æ¥åˆ°aï¼Œç„¶åå†è®©aé“¾æ¥åˆ°b

```rust
    let a = Rc::new(Cons(3,Rc::new(Nil)));
    let b = Rc::new(Cons(1,Rc::clone(&a)));
    println!("{:?}",(*b).0);
```

å…³é”®å°±æ˜¯æ€ä¹ˆè®© a é“¾æ¥åˆ° bï¼Ÿï¼Ÿï¼Ÿ

`(*a).1 = b` è¿™æ ·å¥½åƒä¸è¡Œ

è¿™ä¸ªæ˜¯å…ƒç»„çš„è®¿é—®è¯­æ³•ï¼Œè€Œ `List`æ˜¯ enum æšä¸¾

## æ€ä¹ˆä¿®æ”¹ enum çš„å…³è”å€¼ï¼Ÿ

æ¯”å¦‚
```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let m1 = Message::Quit;
    let m2 = Message::Move{x:1,y:1};
    let m3 = Message::ChangeColor(255,255,0);
}

```

æ€ä¹ˆä¿®æ”¹ `m2` ä» `Message::Move{x:1,y:1}`åˆ° æ¯”å¦‚ `Message::Move{x:100,y:200}`

è¿™é‡Œåªèƒ½é€šè¿‡ pattern match æ‰èƒ½æ¥è§¦åˆ° enum æ•°æ®

```rust

#[derive(Debug)]
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

let mut m2 = Message::Move{x:1,y:1};

match &mut m2 {
    Message::Move { x, y } => {
        *x = 100;
        *y = 200;
    }
    _ => unreachable!(),
}

m2

```


## å†æ”¾é©¬è¿‡æ¥


```rust
#[derive(Debug)]
enum List{
    Cons(i32,Rc<List>),
    Nil,
}

use List::{Cons,Nil};
use std::rc::Rc;

fn main(){
    let mut a = Rc::new(Cons(3,Rc::new(Nil)));
    let b = Rc::new(Cons(1,Rc::clone(&a)));
    println!("{:?}",(*b));

    if let Cons(_val,refer) = &mut *a{
        *refer = Rc::clone(&b);
    }

    println!("{:?}",*b);
}
```


å¥½å§ï¼Œè¿™é‡Œè¿˜æ˜¯ä¸å¯¹ï¼Œ

```rust
error[E0596]: cannot borrow data in an `Rc` as mutable
  --> src/main.rs:16:31
   |
16 |     if let Cons(_val,refer) = &mut *a{
   |                               ^^^^^^^ cannot borrow as mutable
```

> You aren't allowed to modify things that are directly inside an Rc. But you can put a RefCell inside an Rc.



## RefCell<T>

å¦‚æœä¸€ä¸ªå€¼çš„ç±»å‹æ˜¯`RefCell<T>`ï¼Œé‚£ä¹ˆä»–èƒ½è°ƒç”¨ä¸¤ä¸ªå‡½æ•°ï¼Œ`borrow`,`borrow_mut`,å¯¹åº”å¯ä»¥å¾—åˆ°`&`,`& mut`ç±»å‹

ä¸ç¼–è¯‘å™¨æ£€æŸ¥ä¸åŒï¼Œå®ƒæ˜¯åœ¨è¿è¡Œæ—¶å»æ£€æŸ¥ borrowing rulesã€‚ä»€ä¹ˆæ„æ€å‘¢ï¼Ÿ

å°±æ˜¯æ¯è°ƒç”¨ä¸€æ¬¡ `borrow` ä»–å°±ä¼šè®¡ä¸€ä¸‹ï¼Œä¸å¯å˜å¼•ç”¨+1ï¼Œ

å¦‚æœè°ƒç”¨äº† `borrow_mut`ï¼Œä»–ä¼šæ£€æŸ¥ç°åœ¨ä¸å¯å˜å¼•ç”¨è®¡æ•°æœ‰æ²¡æœ‰ï¼Œå¦‚æœæœ‰ï¼Œå› ä¸ºRustçš„å€Ÿç”¨è§„åˆ™ï¼Œä¼šæŠ¥é”™ï¼Œæ­¤æ—¶ä¼španic

è€Œè¿™ä¸€è¿‡ç¨‹æ˜¯åœ¨è¿è¡Œæ—¶é€šè¿‡ä»£ç é€»è¾‘å»æ£€æŸ¥çš„ï¼Œæ‰€ä»¥æ˜¯è¿è¡Œæ—¶æ£€æŸ¥ã€‚åŒæ—¶ä¹Ÿä¼šæŸå¤±ä¸€ç‚¹æ€§èƒ½ï¼Œæ¯”è¾ƒè¦æœ‰é¢å¤–çš„æ£€æŸ¥å¼€é”€

ä½†æ˜¯ä»–èƒ½å¤Ÿæ–¹ä¾¿çš„æä¾›ä¸€äº›ä¿®æ”¹çš„ä¾¿åˆ©æ€§

è¿™ç§èƒ½åŠ›ä¹Ÿè¢«å«åš `interior mutability`

### official demo

```rust
#[derive(Debug)]
enum List {
    Cons(Rc<RefCell<i32>>, Rc<List>),
    Nil,
}

use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

fn main() {
    let value = Rc::new(RefCell::new(5));

    let a = Rc::new(Cons(Rc::clone(&value), Rc::new(Nil)));

    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&a));
    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&a));

    *value.borrow_mut() += 10;

    println!("a after = {:?}", a);
    println!("b after = {:?}", b);
    println!("c after = {:?}", c);
}
```

> By using RefCell<T>, we have an outwardly immutable List value. But we can use the methods on RefCell<T> that provide access to its interior mutability so we can modify our data when we need to

æ€ä¹ˆç†è§£è¿™é‡Œçš„å¯¹å¤–æ˜¯ä¸å¯å˜ï¼Œä½†æ˜¯å¯¹å†…å¯ä»¥ä½¿ç”¨ `interior mutability` å»ä¿®æ”¹å€¼

å¦‚æœæ˜¯è¿™ä¹ˆå®šä¹‰çš„
```rust
enum List{
	Cons(RefCell<i32>,Rc<List>),
	Nil,
}
```

é‚£è¿™ä¹ˆè¯´å¯èƒ½æœ‰ç‚¹é—®é¢˜ï¼Œå› ä¸ºå¯ä»¥é€šè¿‡ æ¨¡å¼åŒ¹é…å¾—åˆ° `RefCell<i32>` ç„¶åä»–å¯ä»¥å¾—åˆ°å¯å˜å¼•ç”¨ï¼Œç„¶åå°±å¯ä»¥ä¿®æ”¹äº†ï¼Œè¿™æ ·å¤–éƒ¨ä¹Ÿæ˜¯å¯å˜çš„


ä½†ç°åœ¨æ˜¯è¿™ä¹ˆå®šä¹‰çš„

```rust
enum List{
	Cons(Rc<RefCell<i32>>,Rc<List>),
	Nil,
}
```


åŠ äº†ä¸€ä¸ª `Rc<...>`ï¼Œ è€Œ`Rc<T>` only gives immutable access to that data.

ä½†å…¶å®è¿™é‡Œä¹Ÿå¯ä»¥é€šè¿‡ b æ¨¡å¼åŒ¹é… å¾—åˆ° aï¼Œç„¶å åœ¨æ¨¡å¼åŒ¹é… è°ƒç”¨borrow_mut å»æ”¹å˜å€¼


```rust
#[derive(Debug)]
enum List {
    Cons(Rc<RefCell<i32>>, Rc<List>),
    Nil,
}

use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

fn main() {
    let value = Rc::new(RefCell::new(5));

    let a = Rc::new(Cons(Rc::clone(&value), Rc::new(Nil)));

    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&a));
    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&a));

    //*value.borrow_mut() += 10;

    println!("a  = {:?}", a);
    println!("b  = {:?}", b);
    println!("c  = {:?}", c);


    if let Cons(ref x,ref y) = b{ // y - &Rc<List>
        if let Cons(ref x1,ref y1) = **y{
            *x1.borrow_mut() += 10;
        }
    }

    println!("a after = {:?}", a);
    println!("b after = {:?}", b);
    println!("c after = {:?}", c);

}

```


## åˆ©ç”¨ interior mutability å»ææ‚æˆ‘ä»¬çš„reference cycle


```rust
#[derive(Debug)]
enum List{
    Cons(i32,RefCell<Rc<List>>),
    Nil,
}

use List::{Cons,Nil};
use std::rc::Rc;
use std::cell::RefCell;

fn main(){
    let a = Rc::new(Cons(3,RefCell::new(Rc::new(Nil))));
    let b = Rc::new(Cons(1,RefCell::new(Rc::clone(&a))));
    println!("{:?}",(*b));

    if let Cons(ref _val, ref refer) =  *a{
        *refer.borrow_mut() = Rc::clone(&b);
    }

    println!("{:?}",*b);
}
```


![2024-04-30-01-36-54-screenshoot.png](../assets/img/2024-04-30-01-36-54-screenshoot.png)


å¤ªå¥½äº†ï¼Œçœ‹åˆ°äº†ç ´åæ•ˆæœï¼Œå¾ˆæ»¡æ„
